const path = require('path');
const simpleGit = require('simple-git/promise');
const matter = require('gray-matter');
const html = require('remark-html');
const remark = require('remark');
const slug = require('remark-slug');
const {JSDOM} = require('jsdom');

const sourceDir = 'docs/source'; // TODO: make configurable
const workingDir = path.resolve(__dirname, '../../apollo-server');
const git = simpleGit(workingDir);

const semverSegment = '(\\d+)(\\.\\d+){2}';
const semverPattern = new RegExp(semverSegment);
const tagPattern = new RegExp(`^v${semverSegment}$`);

exports.createPages = async ({actions}) => {
  const remotes = await git.getRemotes(true);
  const {origin} = remotes.reduce(
    (acc, remote) => ({
      ...acc,
      [remote.name]: remote.refs.fetch
    }),
    {}
  );

  const match = origin.match(/\/[\w-]+\/([\w-]+)\.git$/);
  const patterns = [
    tagPattern,
    new RegExp(`^${match[1]}@${semverSegment}$`) // tags generated by lerna
  ];

  const {all} = await git.tags({'--sort': '-v:refname'});
  const tags = all.filter(tag => patterns.some(pattern => pattern.test(tag)));
  let versions = tags.reduce((acc, tag) => {
    const match = tag.match(semverPattern);
    const version = match[1];
    return !acc[version] ? {...acc, [version]: tag} : acc;
  }, {});

  const versionKeys = Object.keys(versions)
    .sort()
    .reverse();
  const currentVersion = versionKeys[0];
  versions = await Promise.all(
    versionKeys.map(async key => {
      try {
        const version = versions[key];
        const tree = await git.raw(['ls-tree', '-r', version]);

        const objects = tree.split('\n').map(object => ({
          mode: object.slice(0, object.indexOf(' ')),
          path: object.slice(object.lastIndexOf('\t') + 1)
        }));

        const markdown = objects.filter(({path}) => /\.mdx?$/.test(path));
        const paths = markdown.map(file => file.path);
        const docs = markdown.filter(({path}) => !path.indexOf(sourceDir));

        if (!docs.length) {
          throw new Error('Version has no docs');
        }

        const basePath = key === currentVersion ? '/' : `/v${key}`;
        const contents = await Promise.all(
          docs.map(async doc => {
            let text = await git.show([`${version}:${doc.path}`]);
            if (doc.mode === '120000') {
              // the file is a symlink
              const directory = doc.path.slice(0, doc.path.lastIndexOf('/'));
              const symlink = path.resolve(`/${directory}`, text).slice(1);
              if (!paths.includes(symlink)) {
                return null;
              }

              text = await git.show([`${version}:${symlink}`]);
            }

            const {data: frontmatter, content} = matter(text);
            const processed = remark()
              .use(html, {
                sanitize: {
                  allowComments: false
                }
              })
              .use(slug)
              .processSync(content);

            return {
              frontmatter,
              html: processed.contents,
              path:
                basePath +
                doc.path
                  .slice(0, doc.path.lastIndexOf('.'))
                  .replace(sourceDir, '')
                  .replace('/index', '')
            };
          })
        );

        return {
          id: key,
          basePath,
          tag: versions[key],
          contents: contents.filter(
            content => content && Boolean(content.html.replace(/\n/g, ''))
          )
        };
      } catch (error) {
        return null;
      }
    })
  );

  const docsTemplate = require.resolve('./src/templates/docs');
  versions.filter(Boolean).forEach((version, index, array) =>
    version.contents.forEach(({path, frontmatter, html}) => {
      const dom = new JSDOM(html);
      const headings = Array.from(
        dom.window.document.querySelectorAll('h1,h2,h3')
      ).map(heading => ({
        id: heading.id,
        text: heading.textContent
      }));

      actions.createPage({
        path,
        component: docsTemplate,
        context: {
          frontmatter,
          html,
          headings,
          version,
          versions: array
        }
      });
    })
  );
};
