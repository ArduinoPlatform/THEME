const path = require('path');
const simpleGit = require('simple-git/promise');
const matter = require('gray-matter');
const html = require('remark-html');
const remark = require('remark');
const slug = require('remark-slug');
const {JSDOM} = require('jsdom');

const sourceDir = 'docs/source'; // TODO: make configurable
const workingDir = path.resolve(__dirname, '../../apollo-server');
const git = simpleGit(workingDir);

const semverSegment = '(\\d+)(\\.\\d+){2}';
const semverPattern = new RegExp(semverSegment);
const tagPattern = new RegExp(`^v${semverSegment}$`);

exports.createPages = async ({actions}) => {
  const remotes = await git.getRemotes(true);
  const {origin} = remotes.reduce(
    (acc, remote) => ({
      ...acc,
      [remote.name]: remote.refs.fetch
    }),
    {}
  );

  const match = origin.match(/\/[\w-]+\/([\w-]+)\.git$/);
  const patterns = [
    tagPattern,
    new RegExp(`^${match[1]}@${semverSegment}$`) // tags generated by lerna
  ];

  const {all} = await git.tags({'--sort': '-v:refname'});
  const tags = all.filter(tag => patterns.some(pattern => pattern.test(tag)));
  let versions = tags.reduce((acc, tag) => {
    const match = tag.match(semverPattern);
    const version = match[1];
    return !acc[version] ? {...acc, [version]: tag} : acc;
  }, {});

  versions = await Promise.all(
    Object.keys(versions).map(async key => {
      try {
        const version = versions[key];
        const tree = await git.raw(['ls-tree', '-r', '--name-only', version]);

        const paths = tree
          .split('\n')
          .filter(file => !file.indexOf(sourceDir) && /\.mdx?$/.test(file));
        if (!paths.length) {
          throw new Error('Version has no docs');
        }

        const basePath = `v${key}`;
        const contents = await Promise.all(
          paths.map(async path => {
            const text = await git.show([`${version}:${path}`]);
            const {data: frontmatter, content} = matter(text);
            const processed = remark()
              .use(html, {
                sanitize: {
                  allowComments: false
                }
              })
              .use(slug)
              .processSync(content);
            return {
              frontmatter,
              html: processed.contents,
              path:
                basePath +
                path
                  .slice(0, path.lastIndexOf('.'))
                  .replace(sourceDir, '')
                  .replace('/index', '')
            };
          })
        );

        return {
          id: key,
          basePath,
          tag: versions[key],
          contents: contents.filter(content =>
            Boolean(content.html.replace(/\n/g, ''))
          )
        };
      } catch (error) {
        return null;
      }
    })
  );

  const docsTemplate = require.resolve('./src/templates/docs');
  versions.filter(Boolean).forEach((version, index, array) =>
    version.contents.forEach(({path, frontmatter, html}) => {
      const dom = new JSDOM(html);
      const headings = Array.from(
        dom.window.document.querySelectorAll('h1,h2,h3')
      ).map(heading => ({
        id: heading.id,
        text: heading.textContent
      }));

      actions.createPage({
        path,
        component: docsTemplate,
        context: {
          frontmatter,
          html,
          headings,
          version,
          versions: array
        }
      });
    })
  );
};
