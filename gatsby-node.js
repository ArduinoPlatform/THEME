const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git/promise');
const matter = require('gray-matter');
const html = require('remark-html');
const remark = require('remark');
const slug = require('remark-slug');
const yaml = require('js-yaml');
const {JSDOM} = require('jsdom');

const semverSegment = '(\\d+)(\\.\\d+){2}';
const semverPattern = new RegExp(semverSegment);
const tagPattern = new RegExp(`^v${semverSegment}$`);

async function getSidebarCategories(objects, configPaths, git, version) {
  const filePaths = objects.map(object => object.path);
  const existingConfig = configPaths.filter(configPath =>
    filePaths.includes(configPath)
  )[0];

  if (existingConfig) {
    const existingConfigText = await git.show([`${version}:${existingConfig}`]);

    // parse the config if it's YAML
    if (/\.yml$/.test(existingConfig)) {
      const yamlConfig = yaml.safeLoad(existingConfigText);
      return yamlConfig.sidebar_categories;
    }

    // TODO: handle js configs
  }

  return null;
}

exports.createPages = async (
  {actions},
  {rootDir = 'docs', sourceDir = 'source', root, sidebarCategories}
) => {
  const git = simpleGit(path.relative(root, '../apollo-server'));
  const remotes = await git.getRemotes(true);
  const {origin} = remotes.reduce(
    (acc, remote) => ({
      ...acc,
      [remote.name]: remote.refs.fetch
    }),
    {}
  );

  const match = origin.match(/\/[\w-]+\/([\w-]+)\.git$/);
  const patterns = [
    tagPattern,
    new RegExp(`^${match[1]}@${semverSegment}$`) // tags generated by lerna
  ];

  const {all} = await git.tags({'--sort': '-v:refname'});
  const tags = all.filter(tag => patterns.some(pattern => pattern.test(tag)));
  let versions = tags.reduce((acc, tag) => {
    const match = tag.match(semverPattern);
    const version = match[1];
    return !acc[version] ? {...acc, [version]: tag} : acc;
  }, {});

  const versionKeys = Object.keys(versions)
    .sort()
    .reverse();
  const currentVersion = versionKeys[0];
  const fullSourceDir = path.join(rootDir, sourceDir);
  const configPaths = [`${rootDir}/gatsby-config.js`, `${rootDir}/_config.yml`];

  versions = await Promise.all(
    versionKeys.map(async key => {
      try {
        const version = versions[key];
        const tree = await git.raw(['ls-tree', '-r', version]);
        const objects = tree.split('\n').map(object => ({
          mode: object.slice(0, object.indexOf(' ')),
          path: object.slice(object.lastIndexOf('\t') + 1)
        }));

        const isCurrentVersion = key === currentVersion;
        const versionSidebarCategories = isCurrentVersion
          ? sidebarCategories
          : await getSidebarCategories(objects, configPaths, git, version);

        if (!versionSidebarCategories) {
          throw new Error(
            `No sidebar configuration found for this version: ${version}`
          );
        }

        const markdown = objects.filter(({path}) => /\.mdx?$/.test(path));
        const markdownPaths = markdown.map(object => object.path);
        const docs = markdown.filter(({path}) => !path.indexOf(fullSourceDir));

        const contents = {};
        const basePath = isCurrentVersion ? '/' : `/v${key}/`;
        for (const category in versionSidebarCategories) {
          const sidebarItems = versionSidebarCategories[category];
          const categoryContents = await Promise.all(
            sidebarItems.map(async sidebarItem => {
              if (typeof sidebarItem !== 'string') {
                return {
                  link: sidebarItem
                };
              }

              const filePath = `${fullSourceDir}/${sidebarItem}.md`;
              const doc = docs.find(({path}) => path === filePath);
              if (!doc) {
                throw new Error(`Doc not found: ${filePath}`);
              }

              let text = await git.show([`${version}:${filePath}`]);
              if (doc.mode === '120000') {
                // the file is a symlink, so we need to follow it
                const directory = doc.path.slice(0, doc.path.lastIndexOf('/'));
                const symlink = path.resolve(`/${directory}`, text).slice(1);
                if (!markdownPaths.includes(symlink)) {
                  return null;
                }

                text = await git.show([`${version}:${symlink}`]);
              }

              const {data: frontmatter, content} = matter(text);
              const processed = remark()
                .use(html, {
                  sanitize: {
                    allowComments: false,
                    clobber: []
                  }
                })
                .use(slug)
                .processSync(content);

              return {
                frontmatter,
                html: processed.contents,
                path: basePath + sidebarItem.replace(/^index$/, '')
              };
            })
          );

          contents[category] = categoryContents.filter(Boolean);
        }

        const semver = versions[key].match(semverPattern)[0];
        return {
          id: key,
          basePath,
          majorMinor: semver.slice(0, semver.lastIndexOf('.')),
          contents
        };
      } catch (error) {
        console.error(error);
        return null;
      }
    })
  );

  const docsTemplate = require.resolve('./src/templates/docs');
  versions.filter(Boolean).forEach((version, index, array) => {
    for (const key in version.contents) {
      version.contents[key].forEach(({path, frontmatter, html, link}) => {
        if (link) {
          // don't create pages for sidebar links
          return;
        }

        const dom = new JSDOM(html);
        const headings = Array.from(
          dom.window.document.querySelectorAll('h1,h2,h3')
        ).map(heading => ({
          id: heading.id,
          text: heading.textContent
        }));

        actions.createPage({
          path,
          component: docsTemplate,
          context: {
            frontmatter,
            html,
            headings,
            version,
            // use `array` here because we're filtering versions before the loop
            versions: array
          }
        });
      });
    }
  });
};

// include theme files in babel transpilation
exports.onCreateWebpackConfig = ({loaders, actions}) => {
  actions.setWebpackConfig({
    module: {
      rules: [
        {
          test: /\.js$/,
          include: path.dirname(require.resolve('gatsby-theme-apollo')),
          use: [loaders.js()]
        }
      ]
    }
  });
};

// copy the favicon from the theme dir to the built website
exports.onPostBootstrap = (_, {root}) => {
  fs.copyFileSync(
    path.resolve(__dirname, 'static/favicon.ico'),
    path.resolve(root, 'public/favicon.ico')
  );
};
